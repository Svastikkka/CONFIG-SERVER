// @Library("shared-lib@master") _
import groovy.json.JsonOutput
import groovy.json.JsonSlurperClassic
def modifiedFiles = []
def outputFilePath = '/tmp/LastFailedModifiedFiles.txt'

def applyModifiedFiles(modifiedFiles) {
    // Print the list of modified files using a loop
    for (int i = 0; i < modifiedFiles.size(); i++) {
        echo "Complete PATH: ${modifiedFiles[i]}"
        def parts = modifiedFiles[i].split('/')

        def jsonFilePath = "${parts[0]}/PATH.json"
        def keyToExtract = "${parts[2]}"
        def jsonContent = new HashMap(readJSON(file: jsonFilePath))
        if ("${parts[1]}" == "files") {
            keyToExtract = "${parts[2]}"
            fileInfo = new HashMap(jsonContent["files"][keyToExtract])
        } else if ("${parts[1]}" == "docker-config") {
            keyToExtract = "${parts[3]}"
            fileInfo = new HashMap(jsonContent["docker-config"][keyToExtract])
        } else if ("${parts[1]}" == "docker-compose") {
            keyToExtract = "${parts[2]}"
            fileInfo = new HashMap(jsonContent["docker-compose"][keyToExtract])
        } else if ("${parts[1]}" == "schema-psql") {
            keyToExtract = "${parts[2]}"
            fileInfo = new HashMap(jsonContent["schema-psql"][keyToExtract])
        } else if ("${parts[1]}" != "cron" && "${parts[1]}" != "docker-config" && "${parts[1]}" != "docker-compose")  {
            keyToExtract = "${parts[2]}"
            fileInfo = new HashMap(jsonContent[keyToExtract])
        }

        echo "Host: ${parts[0]}"
        echo "Sub Folder: ${parts[1]}"
        if ("${parts[1]}" != "cron" && "${parts[1]}" != "schema-psql"){
            echo "Filename: ${parts[2]}"
            echo "Service: ${fileInfo.service}"
            echo "Path: ${fileInfo.path}"
            echo "Enabled: ${fileInfo.enable}"
            echo "Project: ${fileInfo.project}"
        }
    }
}

pipeline {
    agent any
    parameters {
        booleanParam(name: 'Rebuild', defaultValue: false, description: 'It will reapply new changes in the previous change files')
        string(name: 'BuildBumber', defaultValue: "", description: 'It will reapply changes from particular build')
    }
    stages {
        stage('Print Modified Files') {
            steps {
                script {
                    def excludeFile = { String filePath ->
                        // Add more conditions as needed to exclude specific files
                        filePath.endsWith('.md') || 
                        filePath.endsWith('.png') || 
                        filePath.endsWith('jenkinsfile') || 
                        filePath.endsWith('PATH.json') || 
                        filePath.endsWith('restart.yml') || 
                        filePath.endsWith('files.yml') || 
                        filePath.endsWith('cron.yml') || 
                        filePath.endsWith('main.yml') || 
                        filePath.endsWith('ping.yml') || 
                        filePath.endsWith('docker.yml') || 
                        filePath.endsWith('compose.yml') || 
                        filePath.endsWith('notification.groovy') || 
                        filePath.endsWith('inventory.sh') || 
                        filePath.endsWith('inventory.ini') || 
                        filePath.endsWith('.gitignore') || 
                        filePath.endsWith('Dockerfile') ||
                        filePath.endsWith('netplan.yml') ||
                        filePath.endsWith('ruff.toml') ||
                        filePath.endsWith('schema_validation.py') ||
                        filePath.endsWith('schema_validation.yml') ||
                        filePath.endsWith('_schema.json') ||
                        filePath.endsWith('environment.yml') ||
                        filePath.endsWith('dkms.yml') ||
                        filePath.endsWith('sysctl.yml')                        
                    }
  
                    currentBuild.changeSets.each { changeLogSet ->
                        changeLogSet.items.each { entry ->
                            echo "${entry.commitId} by ${entry.author} on ${new Date(entry.timestamp)}: ${entry.msg}"
                            entry.affectedFiles.each { file ->
                                if (!excludeFile(file.path) && "${file.editType.name}" != "delete") {
                                    echo "${file.editType.name} ${file.path}"
                                    modifiedFiles.add(file.path)
                                } else {
                                    echo "Part of excluded file"
                                }
                            }
                        }
                    }
                    applyModifiedFiles(modifiedFiles)
                    sh "exit 1"                
                }
            }
        }
    }
    post {
        success {
            script {
                // notification("Pipeline job has successfully build")
                echo "Further checks"
            }
        }
        failure {
            script {
                // notification("Pipeline job has failure build")

                // Create LastFailedModifiedFiles.txt and write modified files if there are any
                if (modifiedFiles.size() > 0) {
                    writeFile file: outputFilePath, text: modifiedFiles.join('\n')
                    echo "Modified files written to ${outputFilePath}"
                }
            }
        }
        always {
            script {
                if (params.Rebuild) {
                    def fileContent = readFile(outputFilePath).trim().split('\n').findAll { it.trim() != '' }
                    modifiedFiles.clear()
                    modifiedFiles.addAll(fileContent)
                    echo "Modified Files:\n${fileContent}"
                    applyModifiedFiles(modifiedFiles)
                }
            }
        }
    }
}